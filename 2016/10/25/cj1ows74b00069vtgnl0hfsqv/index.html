<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>JS学习笔记1:闭包 | Moren&#39;s</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="shortcut icon" href="http://yangteng.me/static/favicon.png">
    <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
<nav class="navbar">
    <div class="layout">
        <div class="content ">
            
            
            <a href="/blog/.">Home</a>
            
            
            
            <a href="/blog/archives">Archive</a>
            
            
            
            <a href="http://yangteng.me">About</a>
            
            
        </div>
    </div>
</nav>

<main class="post">
    <article>
    <h1 class="article-title">
        <a href="/blog/2016/10/25/cj1ows74b00069vtgnl0hfsqv/">JS学习笔记1:闭包</a>
    </h1>

    <section class="article-meta">
        <p class="article-date">October 25 2016</p>
    </section>

    <section class="article-entry">
        <p>我们学习JavaScript的时候，常常会听到别人说JS有一个重要的性质就是闭包。闭包可以说确实是一个JS的重要特性，而且并不好理解。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先来看一下闭包直截了当的定义：</p>
<blockquote>
<p>当函数可以记住并访问所在词法的作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>要弄清楚这句话中的意思，我们首先要了解一下JavaScript变量的作用域。JavaScript中的变量无非分为两种：全局变量和局部变量。我们来看下面两个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 1</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>在这段代码中我们使用<code>foo()</code>函数申请调用全局变量<code>a</code>，并输出，得到结果1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>而在第二段代码中，我们在<code>foo()</code>函数中定义了局部变量<code>a</code>，但是无法在函数外部读取，因此没有办法输出<code>a</code>。</p>
<h2 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h2><p>那么问题来了：<strong>我们要如何读取函数中的局部变量</strong>？我们可以通过下面这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>这段代码可以很方便的让我们通过<code>bar()</code>函数访问其外部作用域中的变量<code>a</code>。因为<code>bar()</code>被封闭在<code>foo()</code>内部，其具有一个涵盖<code>foo()</code>作用域的闭包。其实这段代码已经<em>很接近闭包的定义</em>，并且不便于我们观察和理解这个片段中的闭包是如何工作的。</p>
<p>我们再来看下面这段代码，它清晰地展示了闭包：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 4</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line"></div><div class="line">baz(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域。然后我们将<code>bar()</code>函数本身当做一个类型值进行传递（在JavaScript中函数也可以作为一个变量）。</p>
<p>在<code>foo()</code>执行后，其返回值被赋值给变量<code>baz</code>并调用<code>baz()</code>，实际上只是通过不同的标识符引用调用了内部的函数<code>bar()</code>，而在这个例子中，<code>bar()</code>在自己定义的词法作用域以外执行。</p>
<p>由于<code>bar()</code>被声明在<code>foo()</code>中，<strong>因此它涵盖了<code>foo()</code>内部作用域的闭包</strong>，因此在<code>foo()</code>执行后，其内部的作用域并没有被回收。<strong>而<code>foo()</code>内部的闭包可以供<code>bar()</code>在之后的任何时间内引用。</strong></p>
<p><strong><code>bar()</code>依然持有对该作用于的引用，这个引用就叫做闭包。</strong></p>
<p>因此，我们可以简单理解：<strong><em>闭包就是在函数内部定义一个函数，在函数内部和外部搭建起一座桥梁。</em></strong></p>
<hr>
<p>当然，无论我们用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bar(baz);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>通过<code>bar()</code>调用<code>foo()</code>中的<code>baz()</code>，当调用这个内部函数时，它涵盖的<code>foo()</code>内部作用域的闭包就可以被观察到了。</p>
<p>当然传递函数也可以是间接的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  fn = baz;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div><div class="line">fn(); <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<hr>
<p>当然，闭包还有一个重要的用途就是让函数中的变量始终保存在内存中。例如下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 5</span></div><div class="line"><span class="keyword">var</span> add;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    a++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 为了方便我们把这个匿名函数叫做baz</span></div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo();</div><div class="line"></div><div class="line">bar(); <span class="comment">// 1</span></div><div class="line"></div><div class="line">add()；</div><div class="line"></div><div class="line">bar(); <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>在这段代码中，<code>bar()</code>实际上就是<code>foo()</code>返回的匿名函数（ <em><code>baz()</code></em> ）。由于bar是全局变量，因此<code>foo()</code>和他的内部函数就一直被存在了内存中。<br>当然我们也可以利用这个特性创造函数的私有变量和私有方法，例如我们如果尝试获取example 4中bar的a的值，会发现程序报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; console.log(bar.a)</div><div class="line">undefined</div><div class="line">undefined</div></pre></td></tr></table></figure></p>
<h2 id="几个需要注意的例子"><a href="#几个需要注意的例子" class="headerlink" title="几个需要注意的例子"></a>几个需要注意的例子</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>我在查百度了解闭包这个概念的时候，看到了这样的一个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 6</span></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">    <span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 暂且称这个匿名函数为foo吧</span></div><div class="line">            <span class="comment">// console.log(this); // 这行代码帮助看到当前匿名函数的状态</span></div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); </div><div class="line"><span class="comment">// 两个括号是因为调用getNameFunc的时候返回了一个匿名函数（ `foo()` ），为了执行这个函数我们对其传参数（在这里是空参）</span></div></pre></td></tr></table></figure></p>
<p>我们会理所当然的认为example 6这个函数会输出<em>My Object</em>，但实际上当我们运行这个函数的时候，控制台会输出 <code>ReferenceError: name is not defined</code> 。这是为什么呢，其实不难理解。</p>
<p>当我们调用了<code>object</code>中的<code>getNameFunc</code>函数时，它返回了一个匿名函数<code>foo</code>，在我们运行<code>foo</code>这个函数的时候，编译器会在它的作用域中查找局部变量<code>name</code>，但因为<code>foo</code>中并没有定义，因此编译器又回去他的上一级作用域<code>getNameFunc</code>中寻找<code>name</code>，然而在<code>getNameFunc</code>中我们也并没有定义，因此编译器返回到了更上一级也就是与<code>object</code><strong><em>平级</em></strong>的作用域（也就是全局）中寻找<code>name</code>，然而还是没有找到，因此只能输出<code>undefined</code>。</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>如果我们在for循环中试着调用闭包函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 7</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i * <span class="number">500</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们又会理所当然的认为，控制台会分别输出数字 1~5，每隔0.5秒一次，每次一个。<br>但实际上，这段代码运行时会每秒一次地输出5次6。</p>
<p>解释一下原因：</p>
<ul>
<li>首先说一下6是怎么来的：函数的循环终止条件是i&lt;=6，因此条件首次成立时i的值是6。因此输出的结果是循环结束时i的最终值。我们可以在这个<code>for</code>执行完后向控制台输入<code>console.log(i)</code>来看到。</li>
<li><code>for</code>循环中所有<code>setTimeout</code>的回调函数，都在循环结束后才被执行，因此每次都会输出一个6出来</li>
<li>回调函数中的五个函数虽然被分别定义，其实都在共享和调用同一个作用域中的同一个<code>i</code>。</li>
</ul>
<p>我们想要处理这个问题，显然需要更多的作用域。有的人可能会想到把<code>setTimeout</code>当做一个表达式来处理，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">500</span>);</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然而，当你这面这段代码输入到控制台中的时候，会发现其实并没有什么卵用。虽然拥有更多的词法作用域但其实作用域还是空的。因此我们在解决这个问题的时候，还需要增加一些局部变量，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j * <span class="number">500</span>);</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在函数每次执行的时候都预先保存了一个<code>j</code>为当前<code>i</code>的副本，并在接下来的<code>setTimeout</code>中调用它。<br>稍微改写简化一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">500</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么问题就解决了。</p>
<h5 id="另一种解决方法：块作用域"><a href="#另一种解决方法：块作用域" class="headerlink" title="另一种解决方法：块作用域"></a>另一种解决方法：块作用域</h5><p>我们可以在每次迭代的时候都新建一个作用域，换句话说就是我们每次迭代都需要一个块作用域。而<code>let</code>声明可以用来劫持块作用域，其本质上就是将这个块作用域换成一个可以被关闭的作用域。因此我们可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">  &#125;, j * <span class="number">500</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但其实，在<code>for</code>循环头部使用let声明还会有一个特殊的行为：变量在每次迭代的时候都会声明，随后每个迭代都会使用上一个迭代结束时的值来初始化这个变量。因此我们可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i * <span class="number">500</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码和我们之前解决问题时所输出的内容是一样的。</p>
<h2 id="最后扯两句"><a href="#最后扯两句" class="headerlink" title="最后扯两句"></a>最后扯两句</h2><p>闭包这个概念看起来好像很高大上，但其实我们平时在编写JavaScript的时候会经常遇到，只可能我们并没有发现而已。例如ajax中的请求、定时器、事件监听等，只要使用了<em>回调函数</em>，实际上都在使用闭包。</p>
<hr>
<p><em>这个系列的文章用来当做我学习JavaScript时的备忘录和重点记录，以便需要的时候会看。因为我最近在读《你不知道的JavaScript上卷》和《JavaScript设计模式》这两本书，所以文章里的内容大部分都会摘自这里。</em></p>

    </section>
</article>

</main>
<footer class="footer">
    <p>Powered by Moren YANG&nbsp;&nbsp;-&nbsp;&nbsp;ackn. <a href="https://hexo.io"> Hexo </a></p>
</footer>

</body>
</html>
