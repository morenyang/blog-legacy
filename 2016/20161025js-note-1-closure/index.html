<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <title>JS学习笔记1:闭包 | Moren&#39;s</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
    <link rel="apple-touch-icon" sizes="144x144" href="/favicon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css" integrity="sha256-4uFBneYzpMnNUfY7h9Zeiw6uazKIWM9RGXSJqtl6Z/8=" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/style.css"> 
</head>

<body>
<main class="post">
    
<article>

    <nav class="navbar">
    <div class="layout">
        <div class="content">
            
            
            <a href="/.">Home</a>
            
            
            
            <a href="/archives">Archive</a>
            
            
            
            <a href="//yangteng.me">About</a>
            
            
        </div>
    </div>
 </nav>
    
    <div class="header-wrapper">
    
        <header class="article-header">
    
            <div class="placeholder"></div>
            <h1 class="article-title">
                <a href="/2016/20161025js-note-1-closure/">
                    JS学习笔记1:闭包
                </a>
            </h1>

            <div class="article-meta">
                <p class="article-date">
                    Posted October 25 2016
                </p>
            
        </div></header>
    </div>

    <section class="article-entry">
        <p>我们学习JavaScript的时候，常常会听到别人说JS有一个重要的性质就是闭包。闭包可以说确实是一个JS的重要特性，而且并不好理解。<a id="more"></a></p>
<h4>定义</h4>
<p>先来看一下闭包直截了当的定义：</p>
<blockquote>
<p>当函数可以记住并访问所在词法的作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<h2>作用域</h2>
<p>要弄清楚这句话中的意思，我们首先要了解一下JavaScript变量的作用域。JavaScript中的变量无非分为两种：全局变量和局部变量。我们来看下面两个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中我们使用<code>foo()</code>函数申请调用全局变量<code>a</code>，并输出，得到结果1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>而在第二段代码中，我们在<code>foo()</code>函数中定义了局部变量<code>a</code>，但是无法在函数外部读取，因此没有办法输出<code>a</code>。</p>
<h2>闭包的本质</h2>
<p>那么问题来了：<strong>我们要如何读取函数中的局部变量</strong>？我们可以通过下面这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以很方便的让我们通过<code>bar()</code>函数访问其外部作用域中的变量<code>a</code>。因为<code>bar()</code>被封闭在<code>foo()</code>内部，其具有一个涵盖<code>foo()</code>作用域的闭包。其实这段代码已经<em>很接近闭包的定义</em>，并且不便于我们观察和理解这个片段中的闭包是如何工作的。</p>
<p>我们再来看下面这段代码，它清晰地展示了闭包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>函数<code>bar()</code>的词法作用域能够访问<code>foo()</code>的内部作用域。然后我们将<code>bar()</code>函数本身当做一个类型值进行传递（在JavaScript中函数也可以作为一个变量）。</p>
<p>在<code>foo()</code>执行后，其返回值被赋值给变量<code>baz</code>并调用<code>baz()</code>，实际上只是通过不同的标识符引用调用了内部的函数<code>bar()</code>，而在这个例子中，<code>bar()</code>在自己定义的词法作用域以外执行。</p>
<p>由于<code>bar()</code>被声明在<code>foo()</code>中，<strong>因此它涵盖了<code>foo()</code>内部作用域的闭包</strong>，因此在<code>foo()</code>执行后，其内部的作用域并没有被回收。<strong>而<code>foo()</code>内部的闭包可以供<code>bar()</code>在之后的任何时间内引用。</strong></p>
<p><strong><code>bar()</code>依然持有对该作用于的引用，这个引用就叫做闭包。</strong></p>
<p>因此，我们可以简单理解：<strong><em>闭包就是在函数内部定义一个函数，在函数内部和外部搭建起一座桥梁。</em></strong></p>
<hr>
<p>当然，无论我们用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>通过<code>bar()</code>调用<code>foo()</code>中的<code>baz()</code>，当调用这个内部函数时，它涵盖的<code>foo()</code>内部作用域的闭包就可以被观察到了。</p>
<p>当然传递函数也可以是间接的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn = baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>当然，闭包还有一个重要的用途就是让函数中的变量始终保存在内存中。例如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 5</span></span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 为了方便我们把这个匿名函数叫做baz</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">add()；</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>bar()</code>实际上就是<code>foo()</code>返回的匿名函数（ <em><code>baz()</code></em> ）。由于bar是全局变量，因此<code>foo()</code>和他的内部函数就一直被存在了内存中。
当然我们也可以利用这个特性创造函数的私有变量和私有方法，例如我们如果尝试获取example 4中bar的a的值，会发现程序报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(bar.a)</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<h2>几个需要注意的例子</h2>
<h3>例子1</h3>
<p>我在查百度了解闭包这个概念的时候，看到了这样的一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 6</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 暂且称这个匿名函数为foo吧</span></span><br><span class="line">            <span class="comment">// console.log(this); // 这行代码帮助看到当前匿名函数的状态</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); </span><br><span class="line"><span class="comment">// 两个括号是因为调用getNameFunc的时候返回了一个匿名函数（ `foo()` ），为了执行这个函数我们对其传参数（在这里是空参）</span></span><br></pre></td></tr></table></figure>
<p>我们会理所当然的认为example 6这个函数会输出<em>My Object</em>，但实际上当我们运行这个函数的时候，控制台会输出 <code>ReferenceError: name is not defined</code> 。这是为什么呢，其实不难理解。</p>
<p>当我们调用了<code>object</code>中的<code>getNameFunc</code>函数时，它返回了一个匿名函数<code>foo</code>，在我们运行<code>foo</code>这个函数的时候，编译器会在它的作用域中查找局部变量<code>name</code>，但因为<code>foo</code>中并没有定义，因此编译器又回去他的上一级作用域<code>getNameFunc</code>中寻找<code>name</code>，然而在<code>getNameFunc</code>中我们也并没有定义，因此编译器返回到了更上一级也就是与<code>object</code><strong><em>平级</em></strong>的作用域（也就是全局）中寻找<code>name</code>，然而还是没有找到，因此只能输出<code>undefined</code>。</p>
<h3>例子2</h3>
<p>如果我们在for循环中试着调用闭包函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 7</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们又会理所当然的认为，控制台会分别输出数字 1~5，每隔0.5秒一次，每次一个。
但实际上，这段代码运行时会每秒一次地输出5次6。</p>
<p>解释一下原因：</p>
<ul>
<li>首先说一下6是怎么来的：函数的循环终止条件是i&lt;=6，因此条件首次成立时i的值是6。因此输出的结果是循环结束时i的最终值。我们可以在这个<code>for</code>执行完后向控制台输入<code>console.log(i)</code>来看到。</li>
<li><code>for</code>循环中所有<code>setTimeout</code>的回调函数，都在循环结束后才被执行，因此每次都会输出一个6出来</li>
<li>回调函数中的五个函数虽然被分别定义，其实都在共享和调用同一个作用域中的同一个<code>i</code>。</li>
</ul>
<p>我们想要处理这个问题，显然需要更多的作用域。有的人可能会想到把<code>setTimeout</code>当做一个表达式来处理，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">500</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，当你这面这段代码输入到控制台中的时候，会发现其实并没有什么卵用。虽然拥有更多的词法作用域但其实作用域还是空的。因此我们在解决这个问题的时候，还需要增加一些局部变量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">500</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在函数每次执行的时候都预先保存了一个<code>j</code>为当前<code>i</code>的副本，并在接下来的<code>setTimeout</code>中调用它。
稍微改写简化一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">500</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题就解决了。</p>
<h5>另一种解决方法：块作用域</h5>
<p>我们可以在每次迭代的时候都新建一个作用域，换句话说就是我们每次迭代都需要一个块作用域。而<code>let</code>声明可以用来劫持块作用域，其本质上就是将这个块作用域换成一个可以被关闭的作用域。因此我们可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = i;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;, j * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但其实，在<code>for</code>循环头部使用let声明还会有一个特殊的行为：变量在每次迭代的时候都会声明，随后每个迭代都会使用上一个迭代结束时的值来初始化这个变量。因此我们可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和我们之前解决问题时所输出的内容是一样的。</p>
<h2>最后扯两句</h2>
<p>闭包这个概念看起来好像很高大上，但其实我们平时在编写JavaScript的时候会经常遇到，只可能我们并没有发现而已。例如ajax中的请求、定时器、事件监听等，只要使用了<em>回调函数</em>，实际上都在使用闭包。</p>
<hr>
<p><em>这个系列的文章用来当做我学习JavaScript时的备忘录和重点记录，以便需要的时候会看。因为我最近在读《你不知道的JavaScript上卷》和《JavaScript设计模式》这两本书，所以文章里的内容大部分都会摘自这里。</em></p>

    </section>
    
    <section class="article-comments">
        <div id="gitalk-container"></div>
    </section>
    
    <script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script>
        var gitalk = new Gitalk({
            clientID: '6911ddf87e5838ca7da0',
            clientSecret: 'c8b78dec8b54f7009dbd6cce41d42d19eeb0f627',
            id: (window.location.pathname + '').substring(0,50),
            repo: 'blog',
            owner: 'morenyang',
            admin: 'morenyang',
            distractionFreeMode: false
        })
    
        gitalk.render('gitalk-container')
    </script>
</article>

</main>
<footer class="footer">
    <p>Powered by Moren YANG&nbsp;&nbsp;-&nbsp;&nbsp;ackn. <a href="https://hexo.io"> Hexo </a></p>
</footer>

</body>
</html>